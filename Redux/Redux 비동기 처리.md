# Redux 미들웨어

여러분은 [Redux 기초 I] 에서 리액트 생태계에서 가장 사용률이 높은 상태관리 라이브러리인 Redux의 필요성을 알게 되었고 redux로 웹의 상태관리를 해보았습니다.

이번 과목에서는 Redux가 지니고 있는 핵심 기술인 Redux 미들웨어의 개념을 배워봅시다.
Redux는 굉장히 코드가 짧고 가벼운 아키텍처를 가지고 있습니다. Redux는 미들웨어라고 부르는 확장 기능을 지원합니다. 

기본적으로 제공되는 미들웨어 외에 추가로 설치하여 사용해야하는 미들웨어들이 많이 공개되어있는데 이번 장에서는 이 미들웨어 중에서 대표적인 Redux-thunk를 적용하는 기본적인 방법부터 만드는 방법까지 알아봅니다.

Redux 미들웨어를 사용하면 액션이 디스패치 된 다음, 리듀서에서 해당 액션을 받아와서 업데이트하기 전에 추가적인 작업을 할 수 있습니다.

> 액션 - 미들웨어 - 리듀서 - 스토어

## Redux 미들웨어란?

Redux 미들웨어는 리덕스의 기능을 확장할 때 사용하는 기능입니다. 구체적인 예를 몇 가지 들어보겠습니다.

- 액션 로그를 출력하는 미들웨어
- 비동기 처리를 하게 해주는 미들웨어 (redux-thunk 적용)
- 크래시 리포트를 전송하는 미들웨어
- 라우팅을 위해 사용하는 미들웨어

### 이러한 미들웨어가 하는 일

- 특정 조건에 따라 액션이 무시되게 만들 수 있습니다.
- 액션을 콘솔에 출력하거나, 서버 쪽에 로깅을 할 수 있습니다.
- 액션이 디스패치 됐을 때 이를 수정해서 리듀서에게 전달되도록 할 수 있습니다.
- 특정 액션이 발생했을 때 이에 기반하여 다른 액션이 발생되도록 할 수 있습니다.
- 특정 액션이 발생했을 때 특정 자바스크립트 함수를 실행시킬 수 있습니다.

이 미들웨어들은 여러 가지를 조합해서도 사용할 수 있습니다. 리덕스만으로는 조금 불편한 기능을 수많은 개발자들이 미들웨어로 조합해서 만들어 공개하고 있습니다.

미들웨어는 독립적이므로 여러 미들웨어를 사용해도 서로에게 영향을 미치지 않습니다. 그래서 필요한 만큼 여러 개를 조합해서 사용 가능합니다.

## Redux 미들웨어의 구조

미들웨어는 Redux 흐름에서 **액션이 디스패치되는 시점부터 reducer로 처리가 이동할 때까지의 처리를 확장**합니다.
간단하게 미들웨어가 어떠한 형태를 가지는지 살펴봅시다.
```
const middleware = store => next => action {
    console.log('이곳은 "액션이 디스패치 되고 리듀서로 처리가 이동하는 시점의 부분"입니다.');
    const result = next(action);
    return result;
};
```

여기 화살표가 많아서 당황하셨을 수도 있습니다. 이는 “화살표 함수로 result를 리턴하는 함수를 리턴하는 함수를 리턴하는 함수” 를 나타냅니다. 각 함수의 스토어, next, 액션 에서 리턴하는 리턴 값입니다.

위의 리덕스 미들웨어를 일반적인 함수 리터럴로 나타낸다면 이런 형태를 갖게됩니다.
```
const middleware = function(store) {
    return function(next) {
        return function(action) {
            console.log('이곳은 "액션이 디스패치되고 리듀서로 처리가 이동하는 시점의 부분" 입니다.' );
            const result = next(action);
            return result;
        }
    }
};
```
여기서 result는 각 함수의 스토어, next, action에서 리턴하는 리턴 값입니다.

# 동기와 비동기

## 비동기 처리란?

비동기 처리는 말 그대로 동기적이지 않은 처리를 나타냅니다. 동기적인 처리란 작성된 순서대로 실행되는 처리라고 할 수 있습니다. 따라서 비동기 처리란 작성된 순서대로 실행되지 않는 처리라고 할 수 있습니다.

현실세계에서 적용해서 생각해봅시다. 만약 여러분이 음식점에서 피자를 배달하는 배달부라고 가정해봅시다.
시킨 사람이 피자를 다 먹을 때까지 기다렸다가 식사가 끝난 후에야 그 그릇을 가지고 다음 장소로 이동할 수 있다면 어떨까요? 동기코드에서는 시킨 사람이 피자를 먹는 동안 배달부는 아무 일도 할 수 없고 시간당 배달할 수 있는 피자수는 급격하게 줍니다. 비동기 코드에서는 주문했던 배달이 끝나고 그 식사가 끝나기 전에 수행될 일을 미리 알려주고 배달부는 다음 장소로 이동합니다.

동기(Sync) - 작업을 하나의 Thread에서 하도록 시킨 후 그 작업이 끝나길 “기다리고“ 다음 일을 진행한다.

비동기(Async) - 작업을 다른 Thread에서 하도록 시킨 후, 그 작업이 끝나길 “안 기다리고“ 다음 일을 진행한다.

비동기라는 개념이 일반적으로 필요한 경우는 대부분 서버와의 통신(네트워크 작업)이나 외부 API에 접근하는 경우를 들 수 있습니다.
비동기 처리를 실행한 이후에 원하는 코드를 실행하고 싶다면 콜백, Promise, Async/Await 등의 방법을 사용합니다.
```
//동기적인 예
console.log('start');
const a = 100;
const b = 200;
const sum = a + b;
console.log('합계 = ${sum}');
console.log('finish');

/*
실행결과
start
합계 = 300
finish
*/
```

```
//비동기 처리 예
console.log('start');
setTimeout(() => {
const a = 100;
const b = 200;
const sum = a + b;
console.log('합계 = ${sum}');
}, 1000);
console.log('finish');

/*
실행결과
start
finish
합계 = 300
*/
```

이렇게 비동기 처리를 했더니 finish 가 먼저 출력됐습니다. setTimeout 함수 내부의 처리는 비동기적으로 실행되므로 처리가 완료되기를 기다리지 않고 finish를 출력하는 줄이 먼저 실행되는 것입니다. 이 처럼 처리가 완료되기를 기다리지 않고 실행되는 방식을 비동기 처리라고 합니다. setTimeout 외의 비동기 처리의 예로는 API요청, 데이터베이스 접속 등이 있습니다.
